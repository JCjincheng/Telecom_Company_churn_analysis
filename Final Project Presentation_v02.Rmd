---
title: "Final Project Presentation"
author: "Group V"
date: "May 2nd, 2019"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

```{r read in files, eval=TRUE, echo=FALSE}
#setwd("C:/Users/remed/Google Drive/Columbia/Spring 2019/STAT 4243-002 Applied Data Science/Final Project/Final Project Deliverable")
setwd("C:/Users/xujin/Desktop/5243 Data Science/final")
library(data.table)
churn = fread("churn.csv")
#churn <- fread(input = "WA_Fn-UseC_-Telco-Customer-Churn.csv", verbose = FALSE)
```

## Agenda

- Introduction and Descriptions of the data 
- Exploratory Analysis 
- Data Preparation
- Modeling 
- Results 
- Conclusions and Limitations 


## Introduction 

**Customer**: Telecommunication company 

**Problem**: How to retain customers and reduce churn rate? 

- Churn happens when a customer stop doing business with a company

**Goals**: 

- **Identify customer segments** that tend to churn
- **Create predictive model** to predict churn 
- **Create tool for marketing and sales team** to gain customer insights so that they can create **target marketing campaigns** and **retention programs** appropriately 

## Descriptions of the data  

**Teleco Customer Churn data from IBM Watson Analytics**

7043 observations 
21 features (3 numeric variables, 18 categorial variables)

**Outcome variable**: **Churn**

**Predictive variables**: 
```{r churn_names, echo=FALSE}
names(churn[,-21])
```

## Data "cleaning"
- Removed 11 NA values in TotalCharges
- Convert SeniorCitizen from numeric to binary for straightforward illustration
- Removed TotalCharges (high correlation)
- Removed PhoneService (information represented by MultipleLines)
- Removed ID column for model use
- Balanced data by oversampling underrepresented class


## Inbalanced dataset 
### Problem with inbalanced data

- Emphasizing Churn="No" class in accuracy
- High false negative rate

```{r handle_imbalanced_dataset, fig.height=4, fig.width=8, warning=FALSE}
percentage.table <- function(x, digits){
  tab <- table(x)
  percentage.tab <- 100*tab/(sum(tab))
  rounded.tab <- round(x = percentage.tab, digits = digits)
  return(rounded.tab)
}
round.numerics <- function(x, digits){
  if(is.numeric(x)){
    x <- round(x = x, digits = digits)
  }
  return(x)
}
Churn.name <- "Churn"

# BEFORE
# plot the bar chart for churn
churn.tab <- percentage.table(x = churn[, get(Churn.name)], 2) 
churn.table<-as.data.table(churn.tab)
# barplot
before_plot<-ggplot(churn.table,aes(x=unlist(churn.table[, 1]),y=unlist(churn.table[,2]))) + 
  geom_bar(stat="identity",color="black",fill="lightblue") + 
  labs(title="Before Oversampling" , x=eval(Churn.name),y="percentage(%)") + 
  geom_text(aes(label=paste0(unlist(churn.table[,2]),"%"),y=unlist(churn.table[,2])+3.8), size=4)

#AFTER
churn.mod <- ovun.sample(Churn ~ ., data = churn, method = "over",N = 5174*2)$data
# after oversampling
churn.mod.tab <- percentage.table(x=churn.mod$Churn,2)
churn.mod.table <- as.data.table(churn.mod.tab)
#barplot
# barplot
after_plot<-ggplot(churn.mod.table,aes(x=unlist(churn.mod.table[, 1]),y=unlist(churn.mod.table[,2]))) + 
  geom_bar(stat="identity",color="black",fill="lightblue") + 
  labs(title="After Oversampling" , x=eval(Churn.name),y="percentage(%)") + 
  geom_text(aes(label=paste0(unlist(churn.mod.table[,2]),"%"),y=unlist(churn.mod.table[,2])+3.8), size=4)

plot_grid(before_plot,after_plot)
```

## Correlation plot 

```{r correlation, warning=FALSE}
# encoding all factor columns as numeric values
factor.col.name<-col.name[churn[,lapply(X=.SD,FUN="class")]=='factor']
churn_encoded<-copy(churn)
churn_encoded<-churn_encoded[,eval(factor.col.name):=lapply(X=.SD,FUN=function(x){as.numeric(x)-1}),.SD=factor.col.name]
# correlation plots
corrplot(cor(churn_encoded),method='square', type="lower",diag=F, col = colorRampPalette(c("purple", "lightgreen"))(200), tl.col = "black",tl.cex = 0.8,tl.srt=10)

```
**Things we noticed:**      
1. gender, PhoneService vs. Churn 
2. MontlyCharges, Tenure vs. TotalCharges


## Initial Data Exploration
###Churn Rate
```{r data_cleaning, echo=FALSE}
# change the class of columns from char to factor
changeCols <- colnames(churn)[which(as.vector(churn[,lapply(.SD, class)]) == "character")]
churn[,(changeCols):= lapply(.SD, as.factor), .SDcols = changeCols]
# convert SeniorCitizen as a binary class with two levels 'yes' and 'no'
churn[,SeniorCitizen:=factor(SeniorCitizen, levels=c(0,1), labels=c("No", "Yes"))]
# delete missing records
# omit rows where 'x' has a missing value
churn <- na.omit(churn, cols="TotalCharges")
# remove CustomerId featuren column from the dataset
churn <- churn[,2:21]
```


```{r churn_rate, warning=FALSE, results='hide',message=FALSE, fig.height=5, fig.width=8}
library(plyr)
library(ggplot2)
library(cowplot)
library(ROSE)
library(corrplot)

myplots <- list()  
m<-1
# get column names
col.name<-colnames(churn)
 # plot the bar chart for all columns grouped by Churn
for(i in 2:ncol(churn)){
  df.by.churn <- ddply(churn,.(get(col.name[i])), function(x) 
    with(x,data.frame(100*round(table(Churn)/length(Churn),4))))
  df.by.churn<-df.by.churn[c(2,4),]
  
    # bar chart for categorical variables
  if (churn[,class(get(col.name[i]))] == "factor"){
    myplots[[m]] <- eval(substitute(ggplot(data=df.by.churn,aes(x=df.by.churn[,1], y=Freq, fill=Churn)) + geom_bar(stat="identity", color="black",fill="lightblue") + ylim(0,100) + theme(axis.text=element_text(size=8),axis.title=element_text(size=8),plot.title=element_text(size=8),plot.margin = unit(c(0.1, 0, 0, 0), "cm")) + labs(title=eval(col.name[i]),y="Churn Rate(%)", x="") + geom_text(aes(y=Freq, label=paste0(Freq,"%")), hjust=-0.2, color="black", size=3.0) + coord_flip(), list(i = i)))
    m <- m+1
  }
  
}

plot_grid(plotlist = myplots, nrow = 3, ncol = 5)
```


## Initial Data Exploration
###Internet Service

```{r internet_service_plot, warning=FALSE, results='hide',message=FALSE, fig.height=5, fig.width=8}
myplots3 <- list() 

m<-1
# get column names
col.name2<-c("OnlineSecurity", "OnlineBackup", "DeviceProtection", "TechSupport", "StreamingTV", "StreamingMovies")

# plot the bar chart for all columns grouped by Churn
for(i in 1:length(col.name2)){
    #myplots3[[m]]<-eval(substitute(ggplot(churn, aes(churn[,get(col.name2[i])],fill=InternetService))+geom_bar(position='fill')+labs(title = col.name2[i])+xlab("")+theme(axis.text.x=element_text(angle=30,hjust=1)),list(i = i)))
  myplots3[[m]]<-eval(substitute(ggplot(churn, aes(churn[,get(col.name2[i])],fill=InternetService))+geom_bar(position='fill')+labs(title = col.name2[i], x="")+theme(axis.text=element_text(size=8),axis.title=element_text(size=8),plot.title=element_text(size=8),plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),axis.text.x=element_text(angle=30,hjust=1), legend.title = element_text(size=12),legend.text = element_text(size=10)),list(i = i)))

  m <- m+1
}
#plot_grid(plotlist = myplots3, nrow = 2, ncol = 3)
library(ggpubr)
ggarrange(plotlist = myplots3, ncol=3, nrow=2, common.legend = TRUE, legend="left")

```

## Initial Data Exploration 
###Tenure*MonthlyCharge=TotalCharge

```{r check_continuous_relationships, fig.height=3,fig.width=4,fig.align='center'}
# get the product of tenure and MonthlyCharges
continuous.dat <- churn[,.(tenure,MonthlyCharges,TotalCharges, "tenure*MonthlyCharges"=tenure*MonthlyCharges)]
continuous.dat[1:5,]
# use scatterplot to check for the relationship
ggplot(data=churn, aes(x=tenure*MonthlyCharges, y=TotalCharges, color=2)) + geom_point(alpha=0.1,shape=1) + labs(color="",y="TotalCharges", x="tenure*MonthlyCharges") + theme(legend.position="none") + geom_abline(intercept = 0, slope = 1,color="red", size=0.3)
```


## Conclusion 

###Best Model

**RandomForest** = Best Predictive Model 

- **Accuracy**: 83.27%
- **AUC**: 0.8760

###Limitations

- Small dataset 
- Unbalanced dataset 
- Wish we have more features to predict from because currently we have many highly correlated variables 


